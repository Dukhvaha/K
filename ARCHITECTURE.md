# Архитектура проекта

## Обзор

Проект представляет собой модульный Telegram-бот для поиска и просмотра фильмов, построенный на aiogram 3.x с использованием асинхронной архитектуры.

## Структура проекта

### Модули

#### `bot/` - Основной код бота
- **handlers/** - Обработчики команд и сообщений
  - `start.py` - Команда /start
  - `film.py` - Команды /film и /search
  - `help.py` - Команда /help
  - `random.py` - Команда /random
  - `text.py` - Обработка текстовых сообщений
- **keyboards/** - Клавиатуры (inline и reply)
- **middlewares/** - Middleware для обработки запросов
  - `database.py` - Предоставление сессии БД
- **file_storage.py** - Работа с файлами и Telegram CDN
- **main.py** - Точка входа и инициализация бота

#### `database/` - Работа с базой данных
- **connection.py** - Подключение к БД (SQLAlchemy async)
- **models.py** - Модели данных (SQLAlchemy ORM)
  - `VideoCache` - Кеш видео с file_id
  - `UserFavorite` - Избранные фильмы пользователей

#### `services/` - Внешние сервисы
- **downloader.py** - Скачивание видео через aiohttp
- **kinopoisk_service.py** - Интеграция с Kinopoisk API
- **zona_parser_service.py** - Сервис-обертка для парсера
- **zona_parser.py** - Парсер zona.plus через Playwright

#### `config.py` - Конфигурация
- Загрузка настроек из переменных окружения
- Поддержка .env файла
- Обратная совместимость

## Поток данных

### Поиск фильма

1. Пользователь отправляет `/film <название>`
2. Обработчик `film.py` проверяет кеш в БД
3. Если не найдено в кеше:
   - Поиск через Kinopoisk API (метаданные)
   - Поиск видео через zona_parser
   - Скачивание видео
   - Загрузка в приватный Telegram канал
   - Сохранение file_id в БД
4. Отправка видео пользователю через file_id

### Кеширование

- **Уровень 1**: Проверка БД по названию/URL/Kinopoisk ID
- **Уровень 2**: Telegram CDN (file_id)
- **Преимущества**: 
  - Не нужно скачивать повторно
  - Быстрая отправка через file_id
  - Экономия трафика

## База данных

### Модели

#### VideoCache
- `id` - Primary key
- `title` - Название фильма
- `file_id` - Telegram file_id
- `video_url` - Оригинальный URL
- `kinopoisk_id` - ID в Kinopoisk
- `description` - Описание
- `created_at`, `updated_at` - Временные метки

#### UserFavorite
- `id` - Primary key
- `user_id` - ID пользователя Telegram
- `kinopoisk_id` - ID фильма в Kinopoisk
- `created_at` - Время добавления

### Миграции

Используется SQLAlchemy для автоматического создания таблиц при первом запуске.

## Интеграции

### Kinopoisk API
- Используется неофициальный API (kinopoisk.dev)
- Получение метаданных фильмов
- Поиск и случайные фильмы

### Zona.plus Parser
- Playwright для парсинга
- Перехват видео URL через network interception
- Автоматический поиск и извлечение ссылок

### Telegram
- Bot API для отправки сообщений
- Приватный канал как CDN для видео
- Inline и Reply клавиатуры

## Обработка ошибок

- Логирование через стандартный logging
- Try-except блоки в критических местах
- Graceful degradation (fallback на популярные фильмы)
- Информативные сообщения пользователю

## Развертывание

### Development
- SQLite база данных
- Локальный запуск через `python -m bot.main`
- Логи в консоль

### Production
- PostgreSQL база данных
- Docker контейнер
- docker-compose для оркестрации
- CI/CD через GitHub Actions

## Безопасность

- Токены в переменных окружения
- .env файл в .gitignore
- SSL контекст для скачивания видео
- Валидация входных данных

## Масштабирование

### Текущие ограничения
- Один экземпляр бота
- Локальное кеширование в БД

### Возможные улучшения
- Redis для распределенного кеша
- Очереди задач (Celery/RQ)
- Микросервисная архитектура
- Load balancing для парсера

## Мониторинг

- Логирование через logging
- Структурированные логи (готово к structlog)
- Готовность к интеграции с Sentry/Prometheus



